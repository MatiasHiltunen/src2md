use anyhow::{Context, Result};
use memmap2::MmapOptions;
use regex::Regex;
use std::fs::File as StdFile;
use std::path::{Path, PathBuf};
use std::str;
use tokio::fs as tokio_fs;
use tokio::io::AsyncWriteExt;

/// Extracts files from a Markdown file generated by src2md.
/// Optionally takes a target root path to relocate the extracted files.
pub async fn extract_from_markdown(
    md_path: &PathBuf,
    extract_root: Option<&PathBuf>,
) -> Result<()> {
    // Memory-map the markdown file for zero-copy processing
    let file = StdFile::open(md_path)
        .with_context(|| format!("Failed to open markdown file: {}", md_path.display()))?;

    let mmap = unsafe {
        MmapOptions::new()
            .map(&file)
            .with_context(|| format!("Failed to memory-map markdown file: {}", md_path.display()))?
    };

    // Convert the mmap data into a valid UTF-8 string
    let content = str::from_utf8(&mmap)
        .with_context(|| format!("Markdown file is not valid UTF-8: {}", md_path.display()))?;

    // Regex for parsing the markdown headers and code fences
    let header_re = Regex::new(r"(?m)^##\s+(.+)$")?;
    let fence_re = Regex::new(r"(?m)^```[a-zA-Z0-9]*\n(.*?)\n```\\n?").unwrap();

    let mut positions = header_re.find_iter(content).peekable();

    while let Some(header_match) = positions.next() {
        // Get the file path from the markdown header
        let file_path_str = header_re
            .captures(header_match.as_str())
            .and_then(|c| c.get(1))
            .map(|m| m.as_str())
            .unwrap();

        let rel_path = Path::new(file_path_str);

        // Apply the extract root path, if provided
        let out_path = if let Some(root) = extract_root {
            root.join(rel_path)
        } else {
            PathBuf::from(rel_path)
        };

        // Find the content block corresponding to this file
        let start = header_match.end();
        let end = positions.peek().map(|m| m.start()).unwrap_or(content.len());

        let block = &content[start..end];
        if block.contains("(binary file omitted)") {
            continue;
        }

        // If a valid code block is found, write it to the corresponding file
        if let Some(cap) = fence_re.captures(block) {
            let code = cap.get(1).map(|m| m.as_str()).unwrap_or("");

            // Create necessary directories
            if let Some(parent) = out_path.parent() {
                tokio_fs::create_dir_all(parent).await?;
            }

            // Write the extracted code to the file
            let mut file = tokio_fs::File::create(&out_path).await?;
            file.write_all(code.as_bytes()).await?;
        }
    }

    Ok(())
}

