use anyhow::{Context, Result};
use log::debug;
use memmap2::MmapOptions;
use once_cell::sync::Lazy;
use regex::Regex;
use std::fs::File as StdFile;
use std::path::{Path, PathBuf};
use std::str;
use tokio::fs as tokio_fs;
use tokio::io::AsyncWriteExt;

/// Pre-compiled regex for matching markdown headers (## path/to/file)
static HEADER_RE: Lazy<Regex> =
    Lazy::new(|| Regex::new(r"(?m)^##\s+(.+)$").expect("Invalid header regex"));

/// Pre-compiled regex for finding code fence openings
static FENCE_OPEN_RE: Lazy<Regex> =
    Lazy::new(|| Regex::new(r"(?m)^(`{3,})([a-zA-Z0-9]*)$").expect("Invalid fence open regex"));

/// Extracts files from a Markdown file generated by src2md.
/// Optionally takes a target root path to relocate the extracted files.
pub async fn extract_from_markdown(md_path: &PathBuf, extract_root: Option<&PathBuf>) -> Result<()> {
    let file = StdFile::open(md_path)
        .with_context(|| format!("Failed to open markdown file: {}", md_path.display()))?;

    let mmap = unsafe {
        MmapOptions::new()
            .map(&file)
            .with_context(|| format!("Failed to memory-map markdown file: {}", md_path.display()))?
    };

    let content = str::from_utf8(&mmap)
        .with_context(|| format!("Markdown file is not valid UTF-8: {}", md_path.display()))?;

    let mut positions = HEADER_RE.find_iter(content).peekable();
    let mut extracted_count = 0;

    while let Some(header_match) = positions.next() {
        let file_path_str = HEADER_RE
            .captures(header_match.as_str())
            .and_then(|c| c.get(1))
            .map(|m| m.as_str())
            .with_context(|| {
                format!(
                    "Failed to parse file path from header: {}",
                    header_match.as_str()
                )
            })?;

        let rel_path = Path::new(file_path_str)
            .strip_prefix("/")
            .unwrap_or(Path::new(file_path_str));

        let out_path = if let Some(root) = extract_root {
            root.join(rel_path)
        } else {
            rel_path.to_path_buf()
        };

        let start = header_match.end();
        let end = positions.peek().map(|m| m.start()).unwrap_or(content.len());

        let block = &content[start..end];
        if block.contains("(binary file omitted)") {
            debug!("Skipping binary file: {}", out_path.display());
            continue;
        }

        // Find and extract code block with proper fence matching
        if let Some(code) = extract_fenced_code(block) {
            debug!("Extracting: {} ({} bytes)", out_path.display(), code.len());

            if let Some(parent) = out_path.parent() {
                tokio_fs::create_dir_all(parent).await.with_context(|| {
                    format!("Failed to create directory: {}", parent.display())
                })?;
            }

            let mut file = tokio_fs::File::create(&out_path)
                .await
                .with_context(|| format!("Failed to create file: {}", out_path.display()))?;

            file.write_all(code.as_bytes())
                .await
                .with_context(|| format!("Failed to write content to: {}", out_path.display()))?;

            // Ensure data is flushed to disk before returning
            file.sync_all()
                .await
                .with_context(|| format!("Failed to sync file: {}", out_path.display()))?;

            extracted_count += 1;
        }
    }

    debug!("Extracted {} files", extracted_count);
    Ok(())
}

/// Extracts the content from a fenced code block, properly handling nested fences.
///
/// This function finds the opening fence, determines its length, and then searches
/// for a closing fence with the exact same number of backticks.
fn extract_fenced_code(block: &str) -> Option<String> {
    // Find the opening fence
    let open_match = FENCE_OPEN_RE.find(block)?;
    let open_caps = FENCE_OPEN_RE.captures(open_match.as_str())?;

    let fence_backticks = open_caps.get(1)?.as_str();
    let fence_len = fence_backticks.len();

    // Content starts after the opening fence line
    let content_start = open_match.end() + 1; // +1 for the newline after the fence

    if content_start >= block.len() {
        return None;
    }

    let remaining = &block[content_start..];

    // Build a pattern to find the closing fence with exactly the same number of backticks
    // The closing fence must be at the start of a line and have exactly fence_len backticks
    let close_pattern = format!(r"(?m)^`{{{fence_len}}}$");
    let close_re = Regex::new(&close_pattern).ok()?;

    // Find the closing fence
    let close_match = close_re.find(remaining)?;

    // Extract content (everything between open and close fence)
    let code = &remaining[..close_match.start()];

    // Remove trailing newline if present
    let code = code.strip_suffix('\n').unwrap_or(code);

    Some(code.to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::tempdir;

    #[test]
    fn test_extract_fenced_code_simple() {
        let block = r#"

```rust
fn main() {}
```
"#;
        let code = extract_fenced_code(block).unwrap();
        assert_eq!(code, "fn main() {}");
    }

    #[test]
    fn test_extract_fenced_code_with_nested_fences() {
        let block = r#"

````markdown
# Example

```rust
fn main() {}
```
````
"#;
        let code = extract_fenced_code(block).unwrap();
        assert!(code.contains("```rust"));
        assert!(code.contains("fn main() {}"));
    }

    #[test]
    fn test_extract_fenced_code_five_backticks() {
        let block = r#"

`````markdown
Here's a nested block:

````rust
fn nested() {}
````
`````
"#;
        let code = extract_fenced_code(block).unwrap();
        assert!(code.contains("````rust"));
    }

    #[tokio::test]
    async fn test_extract_simple_file() -> Result<()> {
        let temp_dir = tempdir()?;
        let md_path = temp_dir.path().join("test.md");
        let extract_dir = temp_dir.path().join("extracted");

        fs::write(
            &md_path,
            r#"## src/main.rs

```rust
fn main() {
    println!("Hello, world!");
}
```

## src/lib.rs

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```
"#,
        )?;

        extract_from_markdown(&md_path, Some(&extract_dir)).await?;

        let main_content = fs::read_to_string(extract_dir.join("src/main.rs"))?;
        assert!(main_content.contains("Hello, world!"));

        let lib_content = fs::read_to_string(extract_dir.join("src/lib.rs"))?;
        assert!(lib_content.contains("pub fn add"));

        Ok(())
    }

    #[tokio::test]
    async fn test_extract_skips_binary_marker() -> Result<()> {
        let temp_dir = tempdir()?;
        let md_path = temp_dir.path().join("test.md");
        let extract_dir = temp_dir.path().join("extracted");

        fs::write(
            &md_path,
            r#"## assets/image.png

(binary file omitted)

## src/main.rs

```rust
fn main() {}
```
"#,
        )?;

        extract_from_markdown(&md_path, Some(&extract_dir)).await?;

        assert!(!extract_dir.join("assets/image.png").exists());
        assert!(extract_dir.join("src/main.rs").exists());

        Ok(())
    }

    #[tokio::test]
    async fn test_extract_with_extended_fences() -> Result<()> {
        let temp_dir = tempdir()?;
        let md_path = temp_dir.path().join("test.md");
        let extract_dir = temp_dir.path().join("extracted");

        // File containing triple backticks should be wrapped in 4+ backticks
        fs::write(
            &md_path,
            r#"## README.md

````markdown
# Example

```rust
fn main() {}
```
````
"#,
        )?;

        extract_from_markdown(&md_path, Some(&extract_dir)).await?;

        let content = fs::read_to_string(extract_dir.join("README.md"))?;
        assert!(content.contains("```rust"));

        Ok(())
    }

    #[tokio::test]
    async fn test_extract_with_magic_header() -> Result<()> {
        use crate::writer::OUTPUT_MAGIC_HEADER;

        let temp_dir = tempdir()?;
        let md_path = temp_dir.path().join("test.md");
        let extract_dir = temp_dir.path().join("extracted");

        // Create a file with the magic header (like a real src2md output)
        let content = format!(
            r#"{}
## src/main.rs

```rust
fn main() {{
    println!("Extracted!");
}}
```
"#,
            OUTPUT_MAGIC_HEADER
        );
        fs::write(&md_path, content)?;

        extract_from_markdown(&md_path, Some(&extract_dir)).await?;

        let main_content = fs::read_to_string(extract_dir.join("src/main.rs"))?;
        assert!(main_content.contains("Extracted!"));

        Ok(())
    }
}
